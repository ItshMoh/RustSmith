"""
Smith Agent for Rustsmith
Assembles the final Rust project based on output from other agents
"""
import openai
from typing import List, Dict, Any
from config import DEFAULT_MODEL, DEFAULT_TEMPERATURE, MAX_TOKENS
import os
import json
import requests
from dotenv import load_dotenv
load_dotenv()
class SmithAgent:
    def __init__(self):
        self.base_url = "https://anura-testnet.lilypad.tech/api/v1/chat/completions"
        self.api_key = os.getenv('ROUTER_API_KEY')
    
    def _prepare_headers(self) -> Dict[str, str]:
        return {
            "Content-Type": "application/json",
            "Authorization": f"Bearer {self.api_key}"
        }
    
    def process(
        self, 
        project_idea: str, 
        master_workflow: str,  
        context: List[Dict[str, Any]],
        agent_responses: Dict[str, str] = {}
    ) -> str:
        
        parsed_context = ""
        for item in context:
            if isinstance(item, dict) and item.get("answer"):
                parsed_context += f"parsed files:\n{item.get('answer')}\n\n"

        error_context = ""
        for item in context:
            if isinstance(item, dict) and item.get("error"):
                error_context += f"Previous error:\n{item.get('error')}\n\n"
                
        endpoint = f"{self.base_url}"
        """
        Assemble the final Rust project using outputs from specialized agents
        
        Args:
            project_idea (str): The user's project idea
            master_workflow (str): The Master Agent's workflow description
            agent_responses (dict): Dictionary of responses from specialized agents
            context (list): List of past interactions including errors
            
        Returns:
            str: Final assembled project with file paths and content
        """
        system_message = """
        You are the Smith Agent for Rustsmith, a tool that generates Rust projects.
        Your task is to assemble a complete Rust project using the outputs from specialized agents.
        You will be provided the Context which will be a list of dictionary containing the User query, Your code response and the error on the code you generated by the rust compiler. Now when you receive errors you have to regenerate the project with the error fixed.
        while fixing the errors don't give the reason of the error, just the right code, nothing else.
        Follow these guidelines:

        Always generate these files:
        1. Cargo.toml with proper metadata and dependencies
        2. src/main.rs or src/lib.rs as appropriate
        3. Any needed module files under src/
        4. Fix any issues or inconsistencies between the agents' outputs
        Format your response strictly as follows:
    
    [FILE: Cargo.toml]
    ```
    <content>
    ```
    [END FILE]
    
    [FILE: src/main.rs]
    ```
    <content>
    ```
    [END FILE]
    
    [FILE: src/<module_name>.rs]
    ```
    <content>
    ```
    [END FILE]
    
   **Important Rules**:
- You **must** close every file block with `[END FILE]`
- Do **not** skip this format even if there's only one file
- All paths and filenames must be valid and reflect actual module usage

---

## Fixing Errors (When No Agent Response is Given)

If no agent responses are present:
- Refer only to the **latest entry** in the provided context
- Use the `code` and `error` to regenerate corrected project files
- Errors may include missing files caused by incorrect file formatting â€” ensure the proper file format structure is followed to avoid this
- In the errors if you find errors which are related to the dependency version, The error should be like changing the version to some other version then change the dependency version to the version expected by the compiler returned in the error.
---

## Input Fields You Will Receive

- `agent_responses`: Output from specialized agents (if available){agent_responses}
- `parsed_files`: Files generated by agents or Smith Agent previously{parsed_context}
- `error_context`: The error returned by the Rust compiler on the last compiled project{error_context}

        """
        
        # Check if there are any errors in the context to fix
       
        # # Format agent responses
        # agent_responses_str = ""
        # for agent_name, response in agent_responses.items():
        #     agent_responses_str += f"{agent_name.upper()} AGENT OUTPUT:\n{response}\n\n"
        
        user_message = f"""
        Project idea: {project_idea}
            
        """
        
        messages = [
            {"role": "system", "content": system_message},
            {"role": "user", "content": user_message}
        ]
        payload = json.dumps({
    "model": "llama3.1:8b",
    "messages": messages
    
})
        
        response = requests.post(endpoint, headers=self._prepare_headers(), data=payload)
        if response.status_code == 200:
            response_json = response.json()
            # print('response_json', response_json)
            if "choices" in response_json and len(response_json["choices"]) > 0:
                response_text = response_json["choices"][0]["message"]["content"]
                print("Response Text:\n", response_text)
                return response_text
            else:
                print("Error: No valid response content from the API.")
        else:
            print(f"API Error: {response.status_code}, {response.text}")