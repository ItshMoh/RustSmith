"""
Smith Agent for Rustsmith
Assembles the final Rust project based on output from other agents
"""
import openai
from typing import List, Dict, Any
from config import DEFAULT_MODEL, DEFAULT_TEMPERATURE, MAX_TOKENS
import os
import json
import requests
from dotenv import load_dotenv
load_dotenv()
class SmithAgent:
    def __init__(self):
        self.base_url = "https://anura-testnet.lilypad.tech/api/v1/chat/completions"
        self.api_key = os.getenv('ROUTER_API_KEY')
    
    def _prepare_headers(self) -> Dict[str, str]:
        return {
            "Content-Type": "application/json",
            "Authorization": f"Bearer {self.api_key}"
        }
    
    def process(
        self, 
        project_idea: str, 
        master_workflow: str,  
        context: List[Dict[str, Any]],
        agent_responses: Dict[str, str] = {}
    ) -> str:
        
        parsed_context = ""
        for item in context:
            if isinstance(item, dict) and item.get("answer"):
                parsed_context += f"parsed files:\n{item.get('answer')}\n\n"

        error_context = ""
        for item in context:
            if isinstance(item, dict) and item.get("error"):
                error_context += f"Previous error:\n{item.get('error')}\n\n"
                
        endpoint = f"{self.base_url}"
        """
        Assemble the final Rust project using outputs from specialized agents
        
        Args:
            project_idea (str): The user's project idea
            master_workflow (str): The Master Agent's workflow description
            agent_responses (dict): Dictionary of responses from specialized agents
            context (list): List of past interactions including errors
            
        Returns:
            str: Final assembled project with file paths and content
        """
        system_message = """
        You are the Smith Agent for Rustsmith, a tool that generates Rust projects.
        Your task is to assemble a complete Rust project using the outputs from specialized agents.
        You will be provided the Context which will be a list of dictionary containing the User query, Your code response and the error on the code you generated by the rust compiler. Now when you receive errors you have to regenerate the project with the error fixed.
        while fixing the errors don't give the reason of the error, just the right code, nothing else.
        Follow these guidelines:

        Always generate these files:
        1. Cargo.toml with proper metadata and dependencies
        2. src/main.rs or src/lib.rs as appropriate
        3. Any needed module files under src/
        4. Fix any issues or inconsistencies between the agents' outputs
        Format your response strictly as follows:
    
    [FILE: Cargo.toml]
    ```
    <content>
    ```
    [END FILE]
    
    [FILE: src/main.rs]
    ```
    <content>
    ```
    [END FILE]
    
    [FILE: src/<module_name>.rs]
    ```
    <content>
    ```
    [END FILE]
    
    you will always produce the 
    After every file content block, you must write [END FILE]. It is the must. you have to strictly follow the above response format for files.
    Some Instructions to Follow:
    1. whenever you have been provided with no agent responses you just have to look for the answer in the context and fix the error associated with it. You have to look only for the latest answer and its error in the context. 
  
      Agent Responses: 
        {agent_responses}
        Here are the Parsed Files:
        {parsed_files}
        It is the Error on the previous code you generated which is parsed and then compiled by the rust compiler.Sometimes you would have errors like some file not found it will be because you havenot followed the proper format for file response due to which some files can't be parsed.So Follow it properly.
        {error_context}
        """
        
        # Check if there are any errors in the context to fix
       
        # # Format agent responses
        # agent_responses_str = ""
        # for agent_name, response in agent_responses.items():
        #     agent_responses_str += f"{agent_name.upper()} AGENT OUTPUT:\n{response}\n\n"
        
        user_message = f"""
        Project idea: {project_idea}
            
        """
        
        messages = [
            {"role": "system", "content": system_message},
            {"role": "user", "content": user_message}
        ]
        payload = json.dumps({
    "model": "llama3.1:8b",
    "messages": messages
    
})
        
        response = requests.post(endpoint, headers=self._prepare_headers(), data=payload)
        if response.status_code == 200:
            response_json = response.json()
            print('response_json', response_json)
            if "choices" in response_json and len(response_json["choices"]) > 0:
                response_text = response_json["choices"][0]["message"]["content"]
                print("Response Text:\n", response_text)
                return response_text
            else:
                print("Error: No valid response content from the API.")
        else:
            print(f"API Error: {response.status_code}, {response.text}")